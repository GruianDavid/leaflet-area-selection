{"version":3,"sources":["B-Open.svg","../../src/utils.js","../../src/drawing-pane.js","../../src/events.js","../../src/control.js","../../src/index.js","index.js"],"names":["module","exports","toCamelCase","name","index","s","cls","additionalClasses","clsName","styles","setPosition","el","point","offset","nextPoint","Browser","DomUtil","CLICK_EVT","isTrustedEvent","event","window","PANE_NAME","createPane","map","options","newNode","referenceNode","standardPanesContainer","overlayPanesContainer","fadeOnActivation","active","drawingPaneContainer","insertAfter","pane","removeEndClickArea","control","marker","doNothingHandler","onAddPoint","this","clientY","clientX","touch","bbox","x","y","markers","length","once","addEndClickArea","icon","className","iconSize","draggable","_onMarkerDrag","onMarkerDrag","requestAnimationFrame","newEdge","i","onAddMarker","rest","edge","enoughPoints","phase","weight","color","onRemoveMarker","splice","removed","onUpdatePolygon","polygon","dashArray","ev","DomEvent","onUpdateGhostPoints","ghostMarkers","nextMarker","currentLatLng","currentMarker","nextLatLng","newGhostMarker","onGhostMarkerDragStart","onGhostMarkerDrag","onGhostMarkerDragEnd","onPolygonCreationEnd","onActivate","latlng","newPoint","firstPoint","lastPoint","opacity","fillOpacity","target","fakeEvent","onMouseMove","props","pointA","rectDrawStart","pointB","layers","draggingRect","rectDrawEnd","onDraggingRectEnd","vertex1","vertex2","vertex3","vertex4","DrawAreaSelection","onPolygonReady","onPolygonDblClick","onButtonActivate","onButtonDeactivate","initialize","Util","_mapMoveStart","bind","_mapMoveEnd","_handleMouseMove","onAdd","activateButton","classList","add","remove","onRemove","getMap","addUserHelpPanel","panel","help","setPhase","forceClear","container","_map","getPane","touchMarker","firstMarker","translatePolygon","data","hoverClosePoint","outClosePoint","clearMarkers","clearGhostMarkers","clearPolygon","removeFrom","closeLine","deactivate","drawAreaSelection","Icon","Default","prototype","_getIconUrl","mergeOptions","iconRetinaUrl","require","iconUrl","shadowUrl","center","Map","tap","dragging","mobile","setView","tileLayer","attribution","on","MAP_LOADED","addTo","popup","document","createElement","innerHTML","bindPopup","areaSelection","preview","getElementById","textContent","JSON","stringify","toGeoJSON","undefined","scrollTop","scrollHeight","geoJSON","style","console","log","position","addControl"],"mappings":"uJAAAA,EAAOC,QAAU,IAA0B,oC,ykBCGpC,SAASC,EAAYC,GAC1B,OAAOA,kBAEA,qBAAeC,kBAAqBC,oBAArBD,OAA0CC,YAFzDF,YAAP,IAMK,SAASG,EAAIH,GAA8B,IAAxBI,EAAwB,uDAA3C,GACCC,EAAUN,EAAhB,GACA,OAAIO,EAAJ,GACSF,EAAiB,UACjBE,EAAOD,GADU,YACEL,EADF,yBAEjBM,EAAOD,GAFU,YAAxB,GAKKD,EAAoB,GAAH,OAAMJ,EAAN,eAAxB,EAYK,SAASO,EAAYC,EAAIC,GAAsB,IAAfC,EAAe,uDAA/C,KACCC,EAAYD,EAASD,MAAH,GAAxB,EACAD,iBAEII,UAAJ,MACEC,6BAEAL,aAAgBG,IAAhBH,KACAA,YAAeG,IAAfH,MAIG,IAAMM,EAAYF,4BAAlB,QAGA,SAASG,EAAeC,GAC7B,OAAOA,aAAmBC,OAA1B,QC3CK,IAAMC,EAAN,sBAcA,SAASC,EAAWC,EAAKC,GAC9B,IDG0BC,EAASC,ECH7BC,EAAyBJ,+BAA/B,qBACMK,EAdR,SAA8BJ,GAAS,IAC/B,EAAN,EAAM,OAAUK,EAAhB,EAAgBA,iBAQhB,OAPiBb,uBAEfV,EAAI,2BAAD,sBAEcwB,EAAS,GAAK,aAF5B,OAE0CD,EAAmB,kBAJlE,MAY8BE,CAA9B,GDE0BN,ECDdG,GDCuBF,ECDnCM,GDEAN,0BAA+CA,EAA/CA,aCDA,IAAMO,EAAOV,eAAb,GAUA,OADAU,sBARiBd,YAEVD,EAAL,KAGAC,oBACAI,6BAGF,EAyBK,SAASW,EAAmBC,GACjC,IAEMC,EAFMD,EAAZ,SACaZ,QAAb,GACeU,cAAf,uBACA,GACEG,WCzDJ,SAASC,EAAiBlB,GACxBA,iCACAA,kCAOK,SAASmB,EAAWnB,GAAO,WAEhC,IAAIoB,KAAJ,WAGA,IAAMhB,EAAMgB,KAAZ,SACI,EAAJ,EAAI,QAAWC,EAAf,EAAeA,QAEf,QAAIC,YAAJ,IAA6BD,EAAuB,CAClD,IAAME,EAAQvB,iBAAd,GACAsB,EAAUC,EAAVD,QACAD,EAAUE,EAAVF,QAGF,GAAID,KAAJ,YACEhB,mCADF,CAdgC,MAmBhC,EAAQnB,aAnBwB,MAmBhB,KAnBgB,EAqB1BuC,EADYpB,EAAlB,eACA,wBACMqB,EAAIH,EAAUE,EAApB,KACME,EAAIL,EAAUG,EAApB,IACA,IAAIJ,KAAKO,QAAQC,QDHZ,SAAyBZ,EAAS,GAAQ,uBAAR,EAAQ,KAA1C,EAA0C,KACzCZ,EAAMY,EAAZ,SACMF,EAAOV,UAAb,GACMa,EAASpB,uBAAsBV,EAAtBU,sBAAf,GACM2B,EAAOP,EAAb,wBACAA,gCASAA,sBARiBjB,YAEVD,EAAL,KAGAC,oBACAI,6BAE0C,CAC1CyB,MAAM,IAERZ,gCAAsCD,uBAAtCC,IACAA,gCAAsCD,qBAAtCC,IACA1B,EAAY0B,EAAQ,IAAI,EAAJ,QAAT,GAA0B,IAAI,EAAJ,OAAWO,EAAD,MAAV,GAA4BA,EAAD,OAAhEjC,ICdEuC,CAAgBV,KAAM,CAACK,EAAvBK,IAEF,IAAMrC,EAAQ,IAAI,EAAJ,QAAd,GACMsC,EAAO,IAAI,EAAJ,QAAY,CACvBC,UAAW7C,EADY,sBAEvB8C,SAAU,CAAC,GAAI,MAEXhB,EAAS,IAAI,EAAJ,OAAWb,yBAAX,GAA8C,QAE3D8B,WAAW,IAEPC,EAAgBC,OAAtB,MACAnB,YAAkBkB,EAAclD,SAAiBmC,KAAKO,QAAtB1C,OAAhCgC,IACAA,kBAAwBjB,YACtBA,iDAEFiB,gBAAsBjB,YACpBA,iDACAqC,uBAAsB,WACpB,yBAGJ,IAOIT,EAPEU,EAAU,kBAGdrD,SAgBF,GAdAgC,iBAEIW,EAMCR,KAAKO,QARVV,OAEgBjB,YACZA,kCACAI,qDAA6B,GAA7BA,IAEEnB,MAAOA,WAA0BA,QAIvCgC,UACAA,WACAb,0BAEA,OAAInB,EACF,IADkB,eACTsD,GACP,gCACA,8BAAkCJ,EAAlC,IACA,2BACA,4BACA,oCACA,mCAAuCnC,YACrCI,qDACK,UADwB,IAA7BA,IAEEnB,MAAOsD,SATJA,EAAItD,EAAb,EAAwBsD,EAAInB,KAAKO,QAAjC,OAAiDY,IAAK,EAA7CA,KAgBN,SAASC,EAAY,GAA2B,QAAzBvD,aAAyB,MAA3B,KAA2B,EAARwD,EAAQ,yBAC/CrC,EAAMgB,KAAZ,SACMsB,EAAO,CACXzB,OAAQwB,EADG,OAEXhD,MAAOgD,EAAKhD,OAENkC,EAAR,KAAQA,QACR,OAAI1C,EACF0C,UAEAA,gBAEF,IAAMgB,EAAehB,UAArB,EACA,SAAIP,KAAKwB,QACP,EAMO,IAAIjB,UAETA,WAAgB,cAAuB,IAApBV,EAAoB,EAApBA,OACXc,EAAOd,EAAb,UACAc,oBAAyB5C,EAAI,qBAAsBF,qBAAnD8C,MACAd,gBAVFU,WAAgB,YAAgB,IAAbV,EAAa,EAAbA,OACXc,EAAOd,EAAb,UACAc,oBAAyB5C,EAAI,qBAA7B4C,WACAd,iBAWNb,4BACA,WAAIgB,KAAKwB,QACPxC,iCACAgB,KAAA,kBAGF,SAAIA,KAAKwB,QAEHxB,KAAJ,WACEhB,cAAgBgB,KAAhBhB,WAEF,IACEgB,KAAA,UAAiB,IAAI,EAAJ,SACf,CAACO,YAAD,YAAgCA,EAAQA,SAARA,UADjB,aAEf,CACEkB,OADF,EAEEC,MAFF,UAGEd,UAAW,kBAGf5B,WAAagB,KAAbhB,aAKC,SAAS2C,EAAe,GAAe,eAAb9D,aAAa,MAAL,EAAK,EACtCmB,EAAMgB,KAAZ,SAGA,GAFA,KAAQO,QACaA,OAArB,EACA,CAGgBP,KAAKO,QAAQqB,OAAO/D,GAApB,EAAhB,GACAgE,wBACA7C,4BACA,WAAIgB,KAAKwB,OACPxC,iCAEF,IAb4C,eAanCmC,GACP,gCACA,8BAAkCH,UAAlC,IACA,2BACA,4BACA,oCACA,mCAAuCpC,YACrCA,kCACAI,qDACK,UADwB,IAA7BA,IAEEnB,MAAOsD,SAVJA,EAAT,EAAoBA,EAAInB,KAAKO,QAA7B,OAA6CY,IAAK,EAAzCA,GAcTnB,KAAA,kBAMK,SAAS8B,IAAkB,WAC1B9C,EAAMgB,KAAZ,SACQO,EAAR,KAAQA,QACFgB,EAAehB,UAArB,EACMwB,EAAU,IAAI,EAAJ,QACdxB,EAAA,KAAY,YACV,OAD0B,EAAbV,OACb,eAFY,yBAMZ6B,MAAOH,EAAe,oBADxB,yBAEEE,OAFF,IAGOF,GAAgB,CAAES,UAAW,UARtB,IASZpB,UAAW,0BAGfmB,QAAuBE,YACrBC,iCAGFH,iBAAwBE,YAKtB,OAFAC,8BACA,wBACA,KAEElC,KAAJ,SACEhB,cAAgBgB,KAAhBhB,SAEFgB,KAAA,UACAhB,WAAagB,KAAbhB,SAGK,SAASmD,IAAsB,WAC9BnD,EAAMgB,KAAZ,SACAiB,uBAAsB,WACpB,sBAD0B,IAEpB,EAAN,EAAM,QAAWmB,EAAjB,EAAiBA,aACjB7B,WAAgB,cACd,IAAM8B,EAAa9B,EAAQ1C,EAAR0C,GAAqBA,EAAQ1C,EAA7B0C,GAA0CA,EAA7D,GACM+B,EAAgBC,SAAtB,YACMC,EAAaH,SAAnB,YACMhE,EAAQW,yBAA2B,EACtCsD,MAAoBE,EAArB,KADuC,GAEtCF,MAAoBE,EAArB,KAFF,IAKM7B,EAAO,IAAI,EAAJ,QAAY,CACvBC,UAAW7C,EADY,4BAEvB8C,SAAU,CAAC,GAAI,MAEXhB,EAAS,IAAI,EAAJ,OAAWb,yBAAX,GAA8C,QAE3D8B,WAAW,IAEP2B,EAAiB,SAErB5C,UAEFA,UACAA,mBACAA,iBAAuB6C,OAAvB7C,EAAuB6C,IACvB7C,YAAkB8C,UAA6BP,EAA/CvC,SACAA,eAAqB+C,UAAgCR,EAArDvC,SACAuC,UACAvC,iBAKC,SAASgD,IACd,IAAM7D,EAAMgB,KAAZ,SAEAhB,oBACAA,cAAgBgB,KAAhBhB,WACAgB,KAAA,eAEAA,KAAA,gEACAA,KAAA,mBACAhB,iCACAgB,KAAA,iBACAL,QAMK,SAASmD,EAAWlE,GAEzB,GAAKD,EAAL,IAGA,IAAMK,EAAMgB,KAAZ,SAEAA,KAAA,YAAmBhB,WAAnB,SAIAJ,oBACAA,gBAEoBoB,KAAKf,QAAQM,QAAjC,WAA2CS,KAAKwB,OAGzCxB,KAAL,aACEhB,qBAIFgB,KAAA,2BAAgCA,KAAhC,QAAAA,KAAA,GACKpB,EAAL,kBACEoB,KAAA,eAIFA,KAAA,yBAAAA,KAAA,GACKpB,EAAL,mBAEEI,qBACAgB,KAAA,uCACAhB,+CACAgB,KAAA,uBAKC,SAASgB,EAAanD,GAAO,WAC5BmB,EAAMgB,KAAZ,SACA,OAAQpB,YAAU,IACRmE,EAAR,EAAQA,OACR9B,uBAAsB,WACpB,IAAM+B,EAAWhE,yBAAjB,GACQX,EAAU,UAAlB,GAAQA,MACRA,IAAU2E,EAAV3E,EACAA,IAAU2E,EAAV3E,EACAW,4BACAA,qCAKC,SAAS2D,EAAkB9E,GAAO,WACjCmB,EAAMgB,KAAZ,SACA,OAAQpB,YAAU,IACRmE,EAAR,EAAQA,OACR9B,uBAAsB,WAEpB,IAAMgC,EAAa,UAAnB,GACMC,EAAY,UAAarF,EAAb,GAA0B,UAAaA,EAAvC,GAAoD,UAAtE,GACI,EAAJ,cACEmB,cAAgB,EAAhBA,cAEF,eAAoB,IAAI,EAAJ,QAClB,CACEA,yBAA2BiE,EAD7B,SAGEjE,yBAA2BkE,EAJX,QAMlB,CACExB,MADF,oBAEED,OAFF,EAGE0B,QAHF,GAIEC,YAJF,GAKEpB,UAAW,UAGfhD,WAAa,EAAbA,cACAA,gCAKC,SAAS0D,IACd,OAAQ9D,YACNA,+CAIG,SAASgE,EAAqB/E,GAAO,WACpCmB,EAAMgB,KAAZ,SACA,OAAQpB,YAAU,IACRyE,EAAR,EAAQA,OACRA,0CACAA,gBACI,EAAJ,cACErE,cAAgB,EAAhBA,cAEF,IAAMgE,EAAWhE,yBAA2BqE,EAA5C,aAEMjD,EADYpB,EAAlB,eACA,wBACMsE,EAAY,CAChBpD,QAAS8C,IAAa5C,EADN,KAEhBH,QAAS+C,IAAa5C,EAFN,IAGhBvC,MAAOA,EAAQ,GAEjBmB,0BAIG,SAASuE,EAAY3E,GAC1B,IAAKoB,KAAD,eAAmBA,KAAKO,QAAQC,QAAhC,IAAgD5B,SAApD,IAAyEA,UAAqB,CAC5F,IAAMI,EAAMgB,KAAZ,SACA,IAAKA,KAAL,YAAuB,CACrBA,KAAA,cAAqB,CAACpB,EAAD,QAAgBA,EAArC,SACA,IAAM4E,EAAQ,CACZ/B,OADY,EAEZC,MAFY,UAGZd,UAHY,qBAIZuC,QAAS,IAOX,OALAnD,KAAA,cAAoB,IAAI,EAAJ,qBACR,IAAI,EAAJ,YADQ,aAER,IAAI,EAAJ,YAFQ,UAApB,QAIAA,KAAA,gBAGFA,KAAA,YAAmB,CAACpB,EAAD,QAAgBA,EAAnC,SACA,IAAM6E,EAAS,CAACzD,KAAK0D,cAAN,GAAwB9E,EAAvC,SACM+E,EAAS,CAAC/E,EAAD,QAAgBoB,KAAK0D,cAApC,IAEME,EAAS5D,KAAK6D,aAApB,YACAD,gBAAqB,CACnB5E,EAAA,mBAAuB,CAAEkB,QAASF,KAAK8D,YAAhB,GAAgC7D,QAASD,KAAK8D,YAAY,KACjF9E,EAAA,mBAAuB,CAAEkB,QAASuD,EAAX,GAAsBxD,QAASwD,EAAO,KAC7DzE,EAAA,mBAAuB,CAAEkB,QAASF,KAAK0D,cAAhB,GAAkCzD,QAASD,KAAK0D,cAAc,OAEvFE,gBAAqB,CACnB5E,EAAA,mBAAuB,CAAEkB,QAASF,KAAK8D,YAAhB,GAAgC7D,QAASD,KAAK8D,YAAY,KACjF9E,EAAA,mBAAuB,CAAEkB,QAASyD,EAAX,GAAsB1D,QAAS0D,EAAO,KAC7D3E,EAAA,mBAAuB,CAAEkB,QAASF,KAAK0D,cAAhB,GAAkCzD,QAASD,KAAK0D,cAAc,QAKpF,SAASK,IACd/D,KAAA,eACA,IAAMgE,EAAU,CAAE9D,QAASF,KAAK0D,cAAhB,GAAkCzD,QAASD,KAAK0D,cAAc,IACxEO,EAAU,CAAE/D,QAASF,KAAK8D,YAAhB,GAAgC7D,QAASD,KAAK0D,cAAc,IACtEQ,EAAU,CAAEhE,QAASF,KAAK8D,YAAhB,GAAgC7D,QAASD,KAAK8D,YAAY,IACpEK,EAAU,CAAEjE,QAASF,KAAK0D,cAAhB,GAAkCzD,QAASD,KAAK8D,YAAY,IAC5E/D,gBACAA,gBACAA,gBACAA,gBACAC,KAAA,6BACAA,KAAA,mBACAA,KAAA,iBACAA,KAAA,wBAA6BA,KAA7B,M,IChaWoE,EAAoB,iBAAe,CAC9CnF,QAAS,CAEPM,QAFO,EAIPD,kBAJO,EAOP+E,eAAgB,gBAEhBC,kBAAmB,kBAEnBC,iBAAkB,gBAElBC,mBAAoB,mBAGtBC,WAAY,WAAwB,IAAdxF,EAAc,uDAAxB,GACVyF,0BACA1E,KAAA,UAEAA,KAAA,MAAaf,gBAAb,WACAe,KAAA,aAEAA,KAAA,eAEAA,KAAA,mBACAA,KAAA,iBAEAA,KAAA,kBAEAA,KAAA,WAEAA,KAAA,gBAEAA,KAAA,aAEAA,KAAA,eAEAA,KAAA,cAAqBA,KAAK2E,cAAcC,KAAxC5E,MACAA,KAAA,YAAmBA,KAAK6E,YAAYD,KAApC5E,MACAA,KAAA,iBAAwBA,KAAK8E,iBAAiBF,KAA9C5E,OAGF+E,MAAO,YACL/E,KAAA,WAAkBvB,uBAAsBV,EAAxC,kCACAiC,KAAA,eAAsBvB,6BAA6BuB,KAAnD,YAEAA,KAAA,uDACAA,KAAA,kEACAA,KAAA,wCAA8C8C,OAA9C9C,OACAA,KAAA,4CAAkDpB,YAChDA,uBAEFoB,KAAA,eACIA,KAAKgF,eAAeC,UAAUC,IADlC,UAEIlF,KAAKgF,eAAeC,UAAUE,OAFlC,UAGAnF,KAAA,OACA,IAAMN,EAAOX,EAAWC,EAAKgB,KAA7B,SAYA,OAXAA,KAAA,oBACAhB,8CAAiDgB,KAAjDhB,kBACAA,iBAAoBgB,KAApBhB,eACAA,eAAkBgB,KAAlBhB,aACAA,oBAAuBe,OAAvBf,OACAA,qBAAwBoC,OAAxBpC,OACAA,wBAA2B2C,OAA3B3C,OACAA,uBAA0B6D,OAA1B7D,OACAA,yBAA4B8C,OAA5B9C,OACAA,8BAAiCmD,OAAjCnD,OACAA,4BAA+B+E,OAA/B/E,OACOgB,KAAP,YAGFoF,SAAU,YACRpG,iDAAoDgB,KAApDhB,kBACAA,kBAAqBgB,KAArBhB,eACAA,gBAAmBgB,KAAnBhB,aACAA,sBACAA,uBACAA,0BACAA,yBACAA,2BACAA,gCACAA,+BAGFqG,OAAQ,WACN,OAAOrF,KAAP,MAGFqE,eAAgB,WACdrE,KAAA,uBAA4BA,KAA5B,QAAAA,OAGFsE,kBAAmB,YACjBtE,KAAA,0BAA+BA,KAA/B,QAAAA,KAAA,IAGFsF,iBAAiB5F,GACf,IAAM6F,EAAQ9G,uBAAsBV,EAApC,mBACAwH,uCACAA,iCACA,IAAMC,EAAO,6DAAH,OACRhH,UADF,OACEA,yDAEF+G,gBAEA7F,kBAGF+F,SAASjE,GAA2B,IAApBkE,EAAoB,wDAClC1F,KAAA,QACAA,KAAA,wBAAsBwB,GAElBkE,GAAJ,SAAkB1F,KAAKwB,SACrBxB,KAAA,oBACAA,KAAA,eACAA,KAAA,gBAEF,IACM2F,EADO3F,KAAK4F,KAAKC,QAAvB,GACA,WACA7F,KAAA,eACI2F,mBADJ,YAEIA,gBAFJ,aAKFhB,cAAe,WACR3E,KAAKf,QAAV,SAGAe,KAAA,eAGF6E,YAAa,WAAY,WACvB,GAAK7E,KAAKf,QAAV,QAGA,IAAMD,EAAMgB,KAAZ,KACAiB,uBAAsB,WACpB,kBAGF,IACM6E,EADO9G,UAAb,GACoBU,cAApB,uBACA,KAAiB,CACf,IAAMqG,EAAc/F,KAAKO,QAAQ,GAAjC,OACMH,EAAO0F,EAAb,wBAEA3H,EAAY2H,EADE9G,yBAA2B+G,EAAzC,aACgC,IAAI,EAAJ,OAAW3F,EAAD,MAAV,GAA4BA,EAAD,OAA3DjC,IAEF6B,KAAA,qBAGFgG,iBAAkB,WAChB,OAAIhG,KAAKO,QAAQC,OAAjB,CAGA,IAAMxB,EAAMgB,KAAZ,KACAA,KAAA,iBAAsBiG,YACpBA,QAAajH,yBAA2BiH,SAAxCA,gBAEFjG,KAAA,sBAA2BiG,YACzBA,QAAajH,yBAA2BiH,SAAxCA,kBAIJC,gBAAiB,YACXlG,KAAKO,QAAQC,OAAS,GAAKR,KAA/B,WACEA,KAAA,qBAA0BA,KAA1B,OAIJmG,cAAe,YACTnG,KAAJ,WACEA,KAAA,gBAAqBA,KAArB,OAIJoG,aAAc,WAAY,WACxBpG,KAAA,iBAAqB,YAAgB,EAAbH,OACtBA,WAAkB,EAAlBA,SAEFG,KAAA,YAGFqG,kBAAmB,WAAY,WAC7BrG,KAAA,sBAA0B,YAAgB,EAAbH,OAC3BA,WAAkB,EAAlBA,SAEFG,KAAA,iBAGFsG,aAAc,WACZtG,KAAA,SAAgBA,KAAK+B,QAAQwE,WAAWvG,KAAxC,MACAA,KAAA,aACAA,KAAA,WAAkBA,KAAKwG,UAAUD,WAAWvG,KAA5C,MACAA,KAAA,gBAGFyG,WAAY,WACV9G,QACAK,KAAA,0CACAA,KAAA,qDACAA,KAAA,yBAGF8E,iBAAkB,YACX9E,KAAKf,QAAV,QAGAsE,mBChOJmB,wBAAqB,qBAEnBgC,kBDkO+B,WAAwB,IAAdzH,EAAc,uDAAxB,GAC/B,OAAO,IAAImF,EAAX,M,gCE7NKuC,OAAKC,QAAQC,UAAUC,YAC9BH,OAAKC,QAAQG,aAAa,CACxBC,cAAeC,EAAQ,GACvBC,QAASD,EAAQ,IACjBE,UAAWF,EAAQ,MAGrB,IAAMG,EAAS,CAAC,UAAW,YAErBpI,EAAM,IAAIqI,MAAI,OAAQ,CAE1BC,KAAK,EACLC,UAAW/I,UAAQgJ,SAClBC,QAAQL,EAAQ,IAEnBM,oBAAU,qDAAsD,CAC9DC,YACE,4FAEDC,GAAG,QAAQ,WACV/I,OAAOgJ,YAAa,KAErBC,MAAM9I,GAET,IAAM+I,EAAQC,SAASC,cAAc,OACrCF,EAAMG,UAAN,gHACyCvH,IADzC,UAIAd,iBAAOuH,GAAQU,MAAM9I,GAAKmJ,UAAUJ,GAEpC,IAAMK,EAAgB,IAAIhE,EAAkB,CAC1CC,eAAgB,SAACtC,GACf,IAAMsG,EAAUL,SAASM,eAAe,WACxCD,EAAQE,YAAcC,KAAKC,UAAU1G,EAAQ2G,UAAU,QAAIC,EAAW,GACtEN,EAAQO,UAAYP,EAAQQ,cAE9BvE,kBAAmB,SAACvC,EAASnC,EAASqC,GACpB6G,kBAAQ/G,EAAQ2G,YAAa,CAC3CK,MAAO,CACL5F,QAAS,GACTC,YAAa,GACb1B,MAAO,SAGHoG,MAAM9I,GACdY,EAAQ6G,cAEVlC,iBAAkB,WACAyD,SAASM,eAAe,WAChCC,YAAc,4BACtBS,QAAQC,IAAI,8BAEdzE,mBAAoB,SAACzC,GACnB,IAAMsG,EAAUL,SAASM,eAAe,WACxCU,QAAQC,IAAI,eACZZ,EAAQE,YAAR,8CAEFxG,EAAUyG,KAAKC,UAAU1G,EAAQ2G,UAAU,QAAIC,EAAW,GAAK,SAE/DO,SAAU,YAGZlK,EAAImK,WAAWf,K","file":"static/js/main.a5a2d999.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/B-Open.a8695c4b.svg\";","import { Browser, DomUtil } from 'leaflet';\nimport styles from './styles.module.css';\n\nexport function toCamelCase(name) {\n  return name\n    .split('-')\n    .map((s, index) => (index === 0 ? s : `${s[0].toUpperCase()}${s.substring(1)}`))\n    .join('');\n}\n\nexport function cls(name, additionalClasses = '') {\n  const clsName = toCamelCase(name);\n  if (styles[clsName]) {\n    return additionalClasses\n      ? `${styles[clsName]} ${name} ${additionalClasses}`\n      : `${styles[clsName]} ${name}`;\n  }\n  // Fallback to just return name and maybe additional classes\n  return additionalClasses ? `${name} ${additionalClasses}` : name;\n}\n\nexport function insertAfter(newNode, referenceNode) {\n  referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);\n}\n\n/**\n * Like original DomUtil.setPosition, but takes an optional offset\n * @param {DOMElement} el\n * @param {Point} point\n */\nexport function setPosition(el, point, offset = null) {\n  const nextPoint = offset ? point.add(offset) : point;\n  el._leaflet_pos = nextPoint;\n\n  if (Browser.any3d) {\n    DomUtil.setTransform(el, nextPoint);\n  } else {\n    el.style.left = nextPoint.x + 'px';\n    el.style.top = nextPoint.y + 'px';\n  }\n}\n\nexport const CLICK_EVT = Browser.mobile ? 'touchend' : 'click';\n\n// This still needed due to bad Leaflet bug on Safari. See https://github.com/Leaflet/Leaflet/issues/7255\nexport function isTrustedEvent(event) {\n  return event.isTrusted || window.Cypress;\n}\n","import { DomUtil, Point } from 'leaflet';\nimport { cls, insertAfter, setPosition, CLICK_EVT, isTrustedEvent } from './utils';\n\nexport const PANE_NAME = 'area-draw-selection';\n\nfunction drawingPaneContainer(options) {\n  const { active, fadeOnActivation } = options;\n  const drawPane = DomUtil.create(\n    'div',\n    cls(\n      'leaflet-map-overlay-pane',\n      `leaflet-pane${active ? '' : ' inactive'}${fadeOnActivation ? ' fading-enabled' : ''}`\n    )\n  );\n  return drawPane;\n}\n\nexport function createPane(map, options) {\n  const standardPanesContainer = map.getContainer().querySelector('.leaflet-map-pane');\n  const overlayPanesContainer = drawingPaneContainer(options);\n  insertAfter(overlayPanesContainer, standardPanesContainer);\n  const pane = map.createPane(PANE_NAME, overlayPanesContainer);\n  const handler = (event) => {\n    // Non-sense, but required on Safari. Probably related to https://github.com/Leaflet/Leaflet/issues/7255\n    if (!isTrustedEvent(event)) {\n      return;\n    }\n    event.stopPropagation();\n    map.fire('as:point-add', event);\n  };\n  pane.addEventListener(CLICK_EVT, handler);\n  return pane;\n}\n\nexport function addEndClickArea(control, [x, y]) {\n  const map = control.getMap();\n  const pane = map.getPane(PANE_NAME);\n  const marker = DomUtil.create('div', cls('end-selection-area'), pane);\n  const bbox = marker.getBoundingClientRect();\n  marker.setAttribute('role', 'button');\n  const handler = (event) => {\n    // Non-sense, but required on Safari. Probably related to https://github.com/Leaflet/Leaflet/issues/7255\n    if (!isTrustedEvent(event)) {\n      return;\n    }\n    event.stopPropagation();\n    map.fire('as:creation-end');\n  };\n  marker.addEventListener(CLICK_EVT, handler, {\n    once: true,\n  });\n  marker.addEventListener('mouseenter', control.hoverClosePoint.bind(control));\n  marker.addEventListener('mouseleave', control.outClosePoint.bind(control));\n  setPosition(marker, new Point(x, y), new Point(-bbox.width / 2, -bbox.height / 2));\n}\n\nexport function removeEndClickArea(control) {\n  const map = control.getMap();\n  const pane = map.getPane(PANE_NAME);\n  const marker = pane.querySelector('.end-selection-area');\n  if (marker) {\n    marker.remove();\n  }\n}\n","import { DivIcon, Marker, Point, Polygon, Polyline, DomEvent, LayerGroup } from 'leaflet';\nimport { cls, isTrustedEvent, CLICK_EVT } from './utils';\nimport { addEndClickArea, removeEndClickArea } from './drawing-pane';\n\nfunction doNothingHandler(event) {\n  event.originalEvent.preventDefault();\n  event.originalEvent.stopPropagation();\n}\n\n/**\n * Event handler reacting to an add point action\n * @param {MouseEvent|TouchEvent} event\n */\nexport function onAddPoint(event) {\n  // Default behavior while dragging\n  if (this.mapMoving) {\n    return;\n  }\n  const map = this.getMap();\n  let { clientX, clientY } = event;\n  // Touch device\n  if (clientX === undefined && clientY === undefined) {\n    const touch = event.changedTouches[0];\n    clientX = touch.clientX;\n    clientY = touch.clientY;\n  }\n  // We were drawing a rect, so we don't perform the canonical action ans we stop here\n  if (this.rectDrawing) {\n    map.fire('as:dragging-rect-end');\n    return;\n  }\n\n  const { index = null } = event;\n  const container = map.getContainer();\n  const bbox = container.getBoundingClientRect();\n  const x = clientX - bbox.left;\n  const y = clientY - bbox.top;\n  if (this.markers.length === 0) {\n    // this is the first point: let's add a sensible click area on the pane too\n    addEndClickArea(this, [x, y]);\n  }\n  const point = new Point(x, y);\n  const icon = new DivIcon({\n    className: cls('area-select-marker'),\n    iconSize: [16, 16],\n  });\n  const marker = new Marker(map.containerPointToLatLng(point), {\n    icon,\n    draggable: true,\n  });\n  const _onMarkerDrag = onMarkerDrag.bind(this);\n  marker.on('drag', _onMarkerDrag(index === null ? this.markers.length : index));\n  marker.on('dragstart', (event) => {\n    event.target.getElement().classList.add('active');\n  });\n  marker.on('dragend', (event) => {\n    event.target.getElement().classList.remove('active');\n    requestAnimationFrame(() => {\n      this.onPolygonReady();\n    });\n  });\n  const newEdge = {\n    point,\n    marker,\n    index,\n  };\n  marker.on(\n    'dblclick',\n    ((length) => (event) => {\n      event.originalEvent.stopPropagation();\n      map.fire('as:marker-remove', {\n        ...newEdge,\n        index: index === null ? length : index,\n      });\n    })(this.markers.length)\n  );\n  marker.on(CLICK_EVT, doNothingHandler);\n  marker.addTo(map);\n  map.fire('as:marker-add', newEdge);\n  // If this point as not been added at the end, we need to update even handlers HOC params to update index\n  if (index !== null) {\n    for (let i = index + 1; i < this.markers.length; i++) {\n      this.markers[i].marker.off('drag');\n      this.markers[i].marker.on('drag', _onMarkerDrag(i));\n      this.markers[i].marker.off(CLICK_EVT);\n      this.markers[i].marker.on(CLICK_EVT, doNothingHandler);\n      this.markers[i].marker.off('dblclick');\n      this.markers[i].marker.on('dblclick', (event) => {\n        map.fire('as:marker-remove', {\n          ...this.markers[i],\n          index: i,\n        });\n      });\n    }\n  }\n}\n\nexport function onAddMarker({ index = null, ...rest }) {\n  const map = this.getMap();\n  const edge = {\n    marker: rest.marker,\n    point: rest.point,\n  };\n  const { markers } = this;\n  if (index === null) {\n    markers.push(edge);\n  } else {\n    markers.splice(index, 0, edge);\n  }\n  const enoughPoints = markers.length >= 3;\n  if (this.phase === 'draw') {\n    if (!enoughPoints) {\n      markers.forEach(({ marker }) => {\n        const icon = marker.getIcon();\n        icon.options.className = cls('area-select-marker', 'invalid');\n        marker.setIcon(icon);\n      });\n    } else if (markers.length === 3) {\n      // Restore colors\n      markers.forEach(({ marker }, index) => {\n        const icon = marker.getIcon();\n        icon.options.className = cls('area-select-marker', index === 0 ? 'start-marker' : null);\n        marker.setIcon(icon);\n      });\n    }\n  }\n  map.fire('as:update-polygon');\n  if (this.phase === 'adjust') {\n    map.fire('as:update-ghost-points');\n    this.onPolygonReady();\n  }\n\n  if (this.phase === 'draw') {\n    // close line\n    if (this.closeLine) {\n      map.removeLayer(this.closeLine);\n    }\n    if (enoughPoints) {\n      this.closeLine = new Polyline(\n        [markers[0].marker.getLatLng(), markers[markers.length - 1].marker.getLatLng()],\n        {\n          weight: 3,\n          color: '#c0c0c0',\n          className: 'areaCloseLine',\n        }\n      );\n      map.addLayer(this.closeLine);\n    }\n  }\n}\n\nexport function onRemoveMarker({ index = 0 }) {\n  const map = this.getMap();\n  const { markers } = this;\n  const enoughPoints = markers.length > 3;\n  if (!enoughPoints) {\n    return;\n  }\n  const removed = this.markers.splice(index || 0, 1);\n  removed[0].marker.removeFrom(map);\n  map.fire('as:update-polygon');\n  if (this.phase === 'adjust') {\n    map.fire('as:update-ghost-points');\n  }\n  for (let i = index; i < this.markers.length; i++) {\n    this.markers[i].marker.off('drag');\n    this.markers[i].marker.on('drag', onMarkerDrag.bind(this)(i));\n    this.markers[i].marker.off(CLICK_EVT);\n    this.markers[i].marker.on(CLICK_EVT, doNothingHandler);\n    this.markers[i].marker.off('dblclick');\n    this.markers[i].marker.on('dblclick', (event) => {\n      event.originalEvent.stopPropagation();\n      map.fire('as:marker-remove', {\n        ...this.markers[i],\n        index: i,\n      });\n    });\n  }\n  this.onPolygonReady();\n}\n\n/**\n * Refresh the polygon on the map\n */\nexport function onUpdatePolygon() {\n  const map = this.getMap();\n  const { markers } = this;\n  const enoughPoints = markers.length >= 3;\n  const polygon = new Polygon(\n    markers.map(({ marker }) => {\n      return marker.getLatLng();\n      // return map.containerPointToLatLng(point);\n    }),\n    {\n      color: enoughPoints ? 'rgb(45, 123, 200)' : 'rgba(220, 53, 69, 0.7)',\n      weight: 2,\n      ...(!enoughPoints && { dashArray: '5, 10' }),\n      className: 'drawing-area-poligon',\n    }\n  );\n  polygon.on(CLICK_EVT, (ev) => {\n    DomEvent.stopPropagation(ev);\n  });\n\n  polygon.on('dblclick', (ev) => {\n    // Preventing zoom-on-doubleclick is not working. I'll leave hacky workarounds to user's implementation\n    // See https://stackoverflow.com/questions/15406537/disable-map-zoom-on-circlemarker-double-click-in-leaflet\n    DomEvent.stopPropagation(ev);\n    this.onPolygonDblClick(ev);\n    return false;\n  });\n  if (this.polygon) {\n    map.removeLayer(this.polygon);\n  }\n  this.polygon = polygon;\n  map.addLayer(this.polygon);\n}\n\nexport function onUpdateGhostPoints() {\n  const map = this.getMap();\n  requestAnimationFrame(() => {\n    this.clearGhostMarkers();\n    const { markers, ghostMarkers } = this;\n    markers.forEach((currentMarker, index) => {\n      const nextMarker = markers[index + 1] ? markers[index + 1] : markers[0];\n      const currentLatLng = currentMarker.marker.getLatLng();\n      const nextLatLng = nextMarker.marker.getLatLng();\n      const point = map.latLngToContainerPoint([\n        (currentLatLng.lat + nextLatLng.lat) / 2,\n        (currentLatLng.lng + nextLatLng.lng) / 2,\n      ]);\n\n      const icon = new DivIcon({\n        className: cls('area-select-ghost-marker'),\n        iconSize: [16, 16],\n      });\n      const marker = new Marker(map.containerPointToLatLng(point), {\n        icon,\n        draggable: true,\n      });\n      const newGhostMarker = {\n        point,\n        marker,\n      };\n      marker.on(CLICK_EVT, doNothingHandler);\n      marker.on('dblclick', doNothingHandler);\n      marker.on('dragstart', onGhostMarkerDragStart.bind(this)());\n      marker.on('drag', onGhostMarkerDrag.bind(this)(ghostMarkers.length));\n      marker.on('dragend', onGhostMarkerDragEnd.bind(this)(ghostMarkers.length));\n      ghostMarkers.push(newGhostMarker);\n      marker.addTo(map);\n    });\n  });\n}\n\nexport function onPolygonCreationEnd() {\n  const map = this.getMap();\n  // We'll forcly enable the drag on the map (which will be just of the draw pane)\n  map.dragging.enable();\n  map.removeLayer(this.closeLine);\n  this.closeLine = null;\n  // Remove style for the final marker icon\n  this.markers[0].marker.getElement().classList.remove('start-marker');\n  this.setPhase('adjust');\n  map.fire('as:update-ghost-points');\n  this.onPolygonReady();\n  removeEndClickArea(this);\n}\n\n/**\n * Plugin activation (button pressed)\n */\nexport function onActivate(event) {\n  // Non-sense, but required on Safari. Probably related to https://github.com/Leaflet/Leaflet/issues/7255\n  if (!isTrustedEvent(event)) {\n    return;\n  }\n  const map = this.getMap();\n  // storing if the dragging is enabled in the map\n  this._dragStatus = map.dragging._enabled;\n\n  // Let leave to custom callback any call to preventDefault, which will block normal button behaviors\n  // event.preventDefault();\n  event.stopPropagation();\n  event.target.blur();\n  // if current state is active, we need to deactivate\n  const activeState = this.options.active || this.phase === 'adjust';\n  if (activeState) {\n    // Disable dragging if it was enabled before the activation\n    if (!this._dragStatus) {\n      map.dragging.disable();\n    }\n\n    // Calling user's specific event handler\n    this.options.onButtonDeactivate(this.polygon, this, event);\n    if (!event.defaultPrevented) {\n      this.deactivate();\n    }\n  } else {\n    // Calling user's specific event handler\n    this.options.onButtonActivate(this, event);\n    if (!event.defaultPrevented) {\n      // When activating the plugin we'll disable dragging temporarely (in case we are drawing a rect)\n      map.dragging.disable();\n      this.activateButton.classList.add('active');\n      map.getContainer().classList.add('drawing-area');\n      this.setPhase('draw', true);\n    }\n  }\n}\n\nexport function onMarkerDrag(index) {\n  const map = this.getMap();\n  return (event) => {\n    const { latlng } = event;\n    requestAnimationFrame(() => {\n      const newPoint = map.latLngToContainerPoint(latlng);\n      const { point } = this.markers[index];\n      point.x = newPoint.x;\n      point.y = newPoint.y;\n      map.fire('as:update-polygon');\n      map.fire('as:update-ghost-points');\n    });\n  };\n}\n\nexport function onGhostMarkerDrag(index) {\n  const map = this.getMap();\n  return (event) => {\n    const { latlng } = event;\n    requestAnimationFrame(() => {\n      // Given a ghost point, markers to be used as edges are the one at +0 and +1\n      const firstPoint = this.markers[index];\n      const lastPoint = this.markers[index + 1] ? this.markers[index + 1] : this.markers[0];\n      if (this.ghostPolygon) {\n        map.removeLayer(this.ghostPolygon);\n      }\n      this.ghostPolygon = new Polygon(\n        [\n          map.containerPointToLatLng(firstPoint.point),\n          latlng,\n          map.containerPointToLatLng(lastPoint.point),\n        ],\n        {\n          color: 'rgb(45, 123, 200)',\n          weight: 2,\n          opacity: 0.5,\n          fillOpacity: 0.1,\n          dashArray: '5, 10',\n        }\n      );\n      map.addLayer(this.ghostPolygon);\n      map.fire('as:update-polygon');\n    });\n  };\n}\n\nexport function onGhostMarkerDragStart() {\n  return (event) => {\n    event.target.getElement().classList.add('active');\n  };\n}\n\nexport function onGhostMarkerDragEnd(index) {\n  const map = this.getMap();\n  return (event) => {\n    const { target } = event;\n    target.getElement().classList.remove('active');\n    target.removeFrom(map);\n    if (this.ghostPolygon) {\n      map.removeLayer(this.ghostPolygon);\n    }\n    const newPoint = map.latLngToContainerPoint(target.getLatLng());\n    const container = map.getContainer();\n    const bbox = container.getBoundingClientRect();\n    const fakeEvent = {\n      clientX: newPoint.x + bbox.left,\n      clientY: newPoint.y + bbox.top,\n      index: index + 1,\n    };\n    map.fire('as:point-add', fakeEvent);\n  };\n}\n\nexport function onMouseMove(event) {\n  if (!this.mapMoving && this.markers.length === 0 && event.which !== 0 && event.buttons === 1) {\n    const map = this.getMap();\n    if (!this.rectDrawing) {\n      this.rectDrawStart = [event.clientX, event.clientY];\n      const props = {\n        weight: 2,\n        color: '#8B4513',\n        className: 'rect-progress-line',\n        opacity: 0.6,\n      };\n      this.draggingRect = new LayerGroup()\n        .addLayer(new Polyline([], props))\n        .addLayer(new Polyline([], props))\n        .addTo(map);\n      this.rectDrawing = true;\n      return;\n    }\n    this.rectDrawEnd = [event.clientX, event.clientY];\n    const pointA = [this.rectDrawStart[0], event.clientY];\n    const pointB = [event.clientX, this.rectDrawStart[1]];\n\n    const layers = this.draggingRect.getLayers();\n    layers[0].setLatLngs([\n      map.mouseEventToLatLng({ clientX: this.rectDrawEnd[0], clientY: this.rectDrawEnd[1] }),\n      map.mouseEventToLatLng({ clientX: pointA[0], clientY: pointA[1] }),\n      map.mouseEventToLatLng({ clientX: this.rectDrawStart[0], clientY: this.rectDrawStart[1] }),\n    ]);\n    layers[1].setLatLngs([\n      map.mouseEventToLatLng({ clientX: this.rectDrawEnd[0], clientY: this.rectDrawEnd[1] }),\n      map.mouseEventToLatLng({ clientX: pointB[0], clientY: pointB[1] }),\n      map.mouseEventToLatLng({ clientX: this.rectDrawStart[0], clientY: this.rectDrawStart[1] }),\n    ]);\n  }\n}\n\nexport function onDraggingRectEnd() {\n  this.rectDrawing = false;\n  const vertex1 = { clientX: this.rectDrawStart[0], clientY: this.rectDrawStart[1] };\n  const vertex2 = { clientX: this.rectDrawEnd[0], clientY: this.rectDrawStart[1] };\n  const vertex3 = { clientX: this.rectDrawEnd[0], clientY: this.rectDrawEnd[1] };\n  const vertex4 = { clientX: this.rectDrawStart[0], clientY: this.rectDrawEnd[1] };\n  onAddPoint.bind(this)(vertex1);\n  onAddPoint.bind(this)(vertex2);\n  onAddPoint.bind(this)(vertex3);\n  onAddPoint.bind(this)(vertex4);\n  this._map.fire('as:creation-end');\n  this.rectDrawStart = null;\n  this.rectDrawEnd = null;\n  this.draggingRect.removeFrom(this._map);\n}\n","import { DomUtil, Control, Util, Point, Browser } from 'leaflet';\nimport { createPane, removeEndClickArea, PANE_NAME } from './drawing-pane';\nimport { cls, setPosition } from './utils';\nimport {\n  onActivate,\n  onAddMarker,\n  onAddPoint,\n  onDraggingRectEnd,\n  onMouseMove,\n  onPolygonCreationEnd,\n  onRemoveMarker,\n  onUpdateGhostPoints,\n  onUpdatePolygon,\n} from './events';\n\n// import buttonImage from './images/area-icon.png';\n\nexport const DrawAreaSelection = Control.extend({\n  options: {\n    // activate automatically area selection on plugin load\n    active: false,\n    // partially fade the map when draw phase is activated\n    fadeOnActivation: true,\n    /* ******* callbacks ******* */\n    // callback called when draw phase is complete and at every polygon adjustement\n    onPolygonReady: (polygon, control) => {},\n    // callback called when draw phase is complete and double-click is performed on the final polygon\n    onPolygonDblClick: (polygon, control, event) => {},\n    // callback called when user press the activation button\n    onButtonActivate: (control, event) => {},\n    // callback called when user press the button to deactivate (not called when the plugin deactivate itself automatically)\n    onButtonDeactivate: (polygon, control, event) => {},\n  },\n\n  initialize: function (options = {}) {\n    Util.setOptions(this, options);\n    this._map = null;\n    // lifecycle phases: one of inactive, draw, adjust\n    this.phase = options.active ? 'draw' : 'inactive';\n    this.mapMoving = false;\n    // map if in phase of drawing a rectangle\n    this.rectDrawing = false;\n    // where user started to draw a rect\n    this.rectDrawStart = null;\n    this.rectDrawEnd = null;\n    // the dragging rect, composed by two lines\n    this.draggingRect = null;\n    // edge markers used for drawing, next dragging the polygon\n    this.markers = [];\n    // fake markers used for adding rings to the polygon\n    this.ghostMarkers = [];\n    // The actual polygon draw\n    this.polygon = null;\n    // on drawing phase: a line from the last drawn point to the first ones\n    this.closeLine = null;\n\n    this._mapMoveStart = this._mapMoveStart.bind(this);\n    this._mapMoveEnd = this._mapMoveEnd.bind(this);\n    this._handleMouseMove = this._handleMouseMove.bind(this);\n  },\n\n  onAdd: function (map) {\n    this._container = DomUtil.create('div', cls('leaflet-area-selector-control'));\n    this.activateButton = DomUtil.create('button', '', this._container);\n    // this.activateButton.style.backgroundImage = `url('${buttonImage}')`;\n    this.activateButton.setAttribute('aria-label', 'Draw shape');\n    this.activateButton.setAttribute('aria-describedby', 'draw-panel-help');\n    this.activateButton.addEventListener('click', onActivate.bind(this));\n    this.activateButton.addEventListener('dblclick', (event) => {\n      event.stopPropagation();\n    });\n    this.options.active\n      ? this.activateButton.classList.add('active')\n      : this.activateButton.classList.remove('active');\n    this._map = map;\n    const pane = createPane(map, this.options);\n    this.addUserHelpPanel(pane);\n    map.getContainer().addEventListener('mousemove', this._handleMouseMove);\n    map.on('movestart', this._mapMoveStart);\n    map.on('moveend', this._mapMoveEnd);\n    map.on('as:point-add', onAddPoint.bind(this));\n    map.on('as:marker-add', onAddMarker.bind(this));\n    map.on('as:marker-remove', onRemoveMarker.bind(this));\n    map.on('as:creation-end', onPolygonCreationEnd.bind(this));\n    map.on('as:update-polygon', onUpdatePolygon.bind(this));\n    map.on('as:update-ghost-points', onUpdateGhostPoints.bind(this));\n    map.on('as:dragging-rect-end', onDraggingRectEnd.bind(this));\n    return this._container;\n  },\n\n  onRemove: function (map) {\n    map.getContainer().removeEventListener('mousemove', this._handleMouseMove);\n    map.off('movestart', this._mapMoveStart);\n    map.off('moveend', this._mapMoveEnd);\n    map.off('as:point-add');\n    map.off('as:marker-add');\n    map.off('as:marker-remove');\n    map.off('as:creation-end');\n    map.off('as:update-polygon');\n    map.off('as:update-ghost-points');\n    map.off('as:dragging-rect-end');\n  },\n\n  getMap: function () {\n    return this._map;\n  },\n\n  onPolygonReady: function () {\n    this.options.onPolygonReady(this.polygon, this);\n  },\n\n  onPolygonDblClick: function (ev) {\n    this.options.onPolygonDblClick(this.polygon, this, ev);\n  },\n\n  addUserHelpPanel(pane) {\n    const panel = DomUtil.create('div', cls('draw-pane-help'));\n    panel.setAttribute('id', 'draw-panel-help');\n    panel.setAttribute('role', 'tooltip');\n    const help = `Define a polygon by clicking of the map to define vertexes${\n      Browser.mobile ? `.` : ` or click-and-drag to obtain a rectangular shape.`\n    }`;\n    panel.textContent = help;\n\n    pane.appendChild(panel);\n  },\n\n  setPhase(phase, forceClear = false) {\n    this.phase = phase;\n    this.options.active = phase === 'draw';\n    // If we didn't finished to fill a polygon, let's clear all\n    if (forceClear || this.phase === 'draw') {\n      this.clearGhostMarkers();\n      this.clearMarkers();\n      this.clearPolygon();\n    }\n    const pane = this._map.getPane(PANE_NAME);\n    const container = pane.parentNode;\n    this.options.active\n      ? container.classList.remove('inactive')\n      : container.classList.add('inactive');\n  },\n\n  _mapMoveStart: function () {\n    if (!this.options.active) {\n      return;\n    }\n    this.mapMoving = true;\n  },\n\n  _mapMoveEnd: function () {\n    if (!this.options.active) {\n      return;\n    }\n    const map = this._map;\n    requestAnimationFrame(() => {\n      this.mapMoving = false;\n    });\n    // Re-position end of selection HTML element\n    const pane = map.getPane(PANE_NAME);\n    const touchMarker = pane.querySelector('.end-selection-area');\n    if (touchMarker) {\n      const firstMarker = this.markers[0].marker;\n      const bbox = touchMarker.getBoundingClientRect();\n      const point = map.latLngToContainerPoint(firstMarker.getLatLng());\n      setPosition(touchMarker, point, new Point(-bbox.width / 2, -bbox.height / 2));\n    }\n    this.translatePolygon();\n  },\n\n  translatePolygon: function () {\n    if (this.markers.length === 0) {\n      return;\n    }\n    const map = this._map;\n    this.markers.forEach((data) => {\n      data.point = map.latLngToContainerPoint(data.marker.getLatLng());\n    });\n    this.ghostMarkers.forEach((data) => {\n      data.point = map.latLngToContainerPoint(data.marker.getLatLng());\n    });\n  },\n\n  hoverClosePoint: function (event) {\n    if (this.markers.length > 2 && this.closeLine) {\n      this.closeLine.removeFrom(this._map);\n    }\n  },\n\n  outClosePoint: function (event) {\n    if (this.closeLine) {\n      this.closeLine.addTo(this._map);\n    }\n  },\n\n  clearMarkers: function () {\n    this.markers.forEach(({ marker }) => {\n      marker.removeFrom(this._map);\n    });\n    this.markers = [];\n  },\n\n  clearGhostMarkers: function () {\n    this.ghostMarkers.forEach(({ marker }) => {\n      marker.removeFrom(this._map);\n    });\n    this.ghostMarkers = [];\n  },\n\n  clearPolygon: function () {\n    this.polygon && this.polygon.removeFrom(this._map);\n    this.polygon = null;\n    this.closeLine && this.closeLine.removeFrom(this._map);\n    this.closeLine = null;\n  },\n\n  deactivate: function () {\n    removeEndClickArea(this);\n    this.activateButton.classList.remove('active');\n    this._map.getContainer().classList.remove('drawing-area');\n    this.setPhase('inactive', true);\n  },\n\n  _handleMouseMove: function (event) {\n    if (!this.options.active) {\n      return;\n    }\n    onMouseMove.bind(this)(event);\n  },\n});\n\nexport const drawAreaSelection = function (options = {}) {\n  return new DrawAreaSelection(options);\n};\n","import { Util, Control } from 'leaflet';\nimport { DrawAreaSelection, drawAreaSelection } from './control';\n\nUtil.extend(Control, {\n  DrawAreaSelection,\n  drawAreaSelection,\n});\n\nexport { DrawAreaSelection, drawAreaSelection };\n","/* eslint-disable no-console */\nimport { Map, Icon, tileLayer, marker, geoJSON, Browser } from 'leaflet';\nimport 'leaflet/dist/leaflet.css';\nimport '@bopen/leaflet-area-selection/dist/index.css';\nimport { DrawAreaSelection } from '@bopen/leaflet-area-selection';\n\nimport './index.css';\n\nimport icon from './B-Open.svg';\n\n// See https://github.com/Leaflet/Leaflet/issues/4968#issuecomment-483402699\ndelete Icon.Default.prototype._getIconUrl;\nIcon.Default.mergeOptions({\n  iconRetinaUrl: require('leaflet/dist/images/marker-icon-2x.png'),\n  iconUrl: require('leaflet/dist/images/marker-icon.png'),\n  shadowUrl: require('leaflet/dist/images/marker-shadow.png'),\n});\n\nconst center = [41.901493, 12.5009157];\n\nconst map = new Map('root', {\n  // Fix for a bug in Leaflet 1.7.1. See https://github.com/Leaflet/Leaflet/issues/7255\n  tap: false,\n  dragging: !Browser.mobile,\n}).setView(center, 13);\n\ntileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n  attribution:\n    '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors',\n})\n  .on('load', () => {\n    window.MAP_LOADED = true;\n  })\n  .addTo(map);\n\nconst popup = document.createElement('div');\npopup.innerHTML = `<div style=\"text-align: center; font-size: 120%\">B-Open</div>\n<img alt=\"B-Open logo\" width=\"75\" src=\"${icon}\" />\n`;\n\nmarker(center).addTo(map).bindPopup(popup);\n\nconst areaSelection = new DrawAreaSelection({\n  onPolygonReady: (polygon) => {\n    const preview = document.getElementById('polygon');\n    preview.textContent = JSON.stringify(polygon.toGeoJSON(3), undefined, 2);\n    preview.scrollTop = preview.scrollHeight;\n  },\n  onPolygonDblClick: (polygon, control, ev) => {\n    const geojson = geoJSON(polygon.toGeoJSON(), {\n      style: {\n        opacity: 0.5,\n        fillOpacity: 0.2,\n        color: 'red',\n      },\n    });\n    geojson.addTo(map);\n    control.deactivate();\n  },\n  onButtonActivate: () => {\n    const preview = document.getElementById('polygon');\n    preview.textContent = 'Please, draw your polygon';\n    console.log('Please, draw your polygon');\n  },\n  onButtonDeactivate: (polygon) => {\n    const preview = document.getElementById('polygon');\n    console.log('Deactivated');\n    preview.textContent = `Deactivated! Current polygon is:\n\n${polygon ? JSON.stringify(polygon.toGeoJSON(3), undefined, 2) : 'null'}`;\n  },\n  position: 'topleft',\n});\n\nmap.addControl(areaSelection);\n"],"sourceRoot":""}