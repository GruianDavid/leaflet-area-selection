{"version":3,"sources":["../../src/utils.js","../../src/drawing-pane.js","../../src/events.js","../../src/control.js","../../dist/area-icon~bdUaMhse.svg","B-Open.svg","index.js"],"names":["cls","name","additionalClasses","clsName","index","s","toCamelCase","styles","setPosition","el","point","offset","nextPoint","Browser","DomUtil","CLICK_EVT","PANE_NAME","createPane","map","options","newNode","referenceNode","standardPanesContainer","overlayPanesContainer","active","fadeOnActivation","drawingPaneContainer","insertAfter","pane","event","onAddPoint","this","clientX","clientY","touch","bbox","x","y","markers","length","control","marker","once","addEndClickArea","icon","className","iconSize","draggable","_onMarkerDrag","onMarkerDrag","newEdge","i","onAddMarker","rest","edge","enoughPoints","phase","weight","color","onRemoveMarker","splice","removed","onUpdatePolygon","polygon","dashArray","onUpdateGhostPoints","global","ghostMarkers","nextMarker","currentLatLng","currentMarker","nextLatLng","newGhostMarker","onGhostMarkerDrag","onGhostMarkerDragStart","onGhostMarkerDragEnd","onPolygonCreationEnd","onActivate","activeState","activateButton","classList","remove","add","latlng","newPoint","firstPoint","lastPoint","opacity","fillOpacity","target","fakeEvent","DrawAreaSelection","onPolygonReady","initialize","Util","mapMoveStart","bind","mapMoveEnd","onAdd","onRemove","getMap","setPhase","forceClear","container","_map","getPane","touchMarker","firstMarker","translatePolygon","data","hoverClosePoint","outClosePoint","clearMarkers","clearGhostMarkers","clearPolygon","removeFrom","closeLine","module","exports","L","Icon","Default","prototype","_getIconUrl","mergeOptions","iconRetinaUrl","require","iconUrl","shadowUrl","center","setView","tileLayer","attribution","addTo","popup","document","createElement","innerHTML","tap","bindPopup","areaSelection","preview","getElementById","innerText","JSON","stringify","toGeoJSON","undefined","scrollTop","scrollHeight","position","addControl"],"mappings":"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","file":"static/js/main.ac9fac70.chunk.js","sourcesContent":["import { Browser, DomUtil } from 'leaflet';\nimport styles from './styles.module.css';\n\nexport function toCamelCase(name) {\n  return name\n    .split('-')\n    .map((s, index) => (index === 0 ? s : `${s[0].toUpperCase()}${s.substring(1)}`))\n    .join('');\n}\n\nexport function cls(name, additionalClasses = '') {\n  const clsName = toCamelCase(name);\n  if (styles[clsName]) {\n    return additionalClasses\n      ? `${styles[clsName]} ${name} ${additionalClasses}`\n      : `${styles[clsName]} ${name}`;\n  }\n  // Fallback to just return name and maybe additional classes\n  return additionalClasses ? `${name} ${additionalClasses}` : name;\n}\n\nexport function insertAfter(newNode, referenceNode) {\n  referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);\n}\n\n/**\n * Like original DomUtil.setPosition, but takes an optional offset\n * @param {DOMElement} el\n * @param {Point} point\n */\nexport function setPosition(el, point, offset = null) {\n  const nextPoint = offset ? point.add(offset) : point;\n  el._leaflet_pos = nextPoint;\n\n  if (Browser.any3d) {\n    DomUtil.setTransform(el, nextPoint);\n  } else {\n    el.style.left = nextPoint.x + 'px';\n    el.style.top = nextPoint.y + 'px';\n  }\n}\n\nexport const CLICK_EVT = Browser.mobile ? 'touchstart' : 'click';\n","import { DomUtil, Point } from 'leaflet';\nimport { cls, insertAfter, setPosition, CLICK_EVT } from './utils';\n\nexport const PANE_NAME = 'area-draw-selection';\n\nfunction drawingPaneContainer(options) {\n  const { active, fadeOnActivation } = options;\n  const drawPane = DomUtil.create(\n    'div',\n    cls(\n      'leaflet-map-overlay-pane',\n      `leaflet-pane${active ? '' : ' inactive'}${fadeOnActivation ? ' fading-enabled' : ''}`\n    )\n  );\n  return drawPane;\n}\n\nexport function createPane(map, options) {\n  const standardPanesContainer = map.getContainer().querySelector('.leaflet-map-pane');\n  const overlayPanesContainer = drawingPaneContainer(options);\n  insertAfter(overlayPanesContainer, standardPanesContainer);\n  const pane = map.createPane(PANE_NAME, overlayPanesContainer);\n  const handler = (event) => {\n    // Non-sense, but required on Safari. Probably related to https://github.com/Leaflet/Leaflet/issues/7255\n    if (!event.isTrusted) {\n      return;\n    }\n    event.stopPropagation();\n    map.fire('as:point-add', event);\n  };\n  pane.addEventListener(CLICK_EVT, handler);\n  pane.style.zIndex = 550;\n}\n\nexport function addEndClickArea(control, [x, y]) {\n  const map = control.getMap();\n  const pane = map.getPane(PANE_NAME);\n  const marker = DomUtil.create('div', cls('end-selection-area'), pane);\n  const bbox = marker.getBoundingClientRect();\n  marker.setAttribute('role', 'button');\n  const handler = (event) => {\n    // Non-sense, but required on Safari. Probably related to https://github.com/Leaflet/Leaflet/issues/7255\n    if (!event.isTrusted) {\n      return;\n    }\n    event.stopPropagation();\n    map.fire('as:creation-end');\n  };\n  marker.addEventListener(CLICK_EVT, handler, {\n    once: true,\n  });\n  marker.addEventListener('mouseenter', control.hoverClosePoint.bind(control));\n  marker.addEventListener('mouseleave', control.outClosePoint.bind(control));\n  setPosition(marker, new Point(x, y), new Point(-bbox.width / 2, -bbox.height / 2));\n}\n","import { DivIcon, Marker, Point, Polygon, Polyline } from 'leaflet';\nimport { cls } from './utils';\nimport { addEndClickArea } from './drawing-pane';\n\n/**\n * Event handler reacting to an add point action\n * @param {MouseEvent|TouchEvent} event\n */\nexport function onAddPoint(event) {\n  // Default behavior while dragging\n  if (this.map_moving) {\n    return;\n  }\n  const { index = null } = event;\n  let { clientX, clientY } = event;\n  if (clientX === undefined && clientY === undefined) {\n    const touch = event.touches[0];\n    clientX = touch.clientX;\n    clientY = touch.clientY;\n  }\n  const map = this.getMap();\n  const container = map.getContainer();\n  const bbox = container.getBoundingClientRect();\n  const x = clientX - bbox.left;\n  const y = clientY - bbox.top;\n  if (this.markers.length === 0) {\n    // this is the first point: let's add a sensible click area on the pane too\n    addEndClickArea(this, [x, y]);\n  }\n  const point = new Point(x, y);\n  const icon = new DivIcon({\n    className: cls('area-select-marker'),\n    iconSize: [16, 16],\n  });\n  const marker = new Marker(map.containerPointToLatLng(point), {\n    icon,\n    draggable: true,\n  });\n  const _onMarkerDrag = onMarkerDrag.bind(this);\n  marker.on('drag', _onMarkerDrag(index === null ? this.markers.length : index));\n  marker.on('dragstart', (event) => {\n    event.target.getElement().classList.add('active');\n  });\n  marker.on('dragend', (event) => {\n    event.target.getElement().classList.remove('active');\n  });\n  const newEdge = {\n    point,\n    marker,\n    index,\n  };\n  marker.on(\n    'dblclick',\n    ((length) => (event) => {\n      map.fire('as:marker-remove', {\n        ...newEdge,\n        index: index === null ? length : index,\n      });\n    })(this.markers.length)\n  );\n  marker.addTo(map);\n  map.fire('as:marker-add', newEdge);\n  // If this point as not been added at the end, we need to update even handlers HOC params to update index\n  if (index !== null) {\n    for (let i = index + 1; i < this.markers.length; i++) {\n      this.markers[i].marker.off('drag');\n      this.markers[i].marker.on('drag', _onMarkerDrag(i));\n      this.markers[i].marker.off('dblclick');\n      this.markers[i].marker.on('dblclick', (event) => {\n        map.fire('as:marker-remove', {\n          ...this.markers[i],\n          index: i,\n        });\n      });\n    }\n  }\n}\n\nexport function onAddMarker({ index = null, ...rest }) {\n  const map = this.getMap();\n  const edge = {\n    marker: rest.marker,\n    point: rest.point,\n  };\n  const { markers } = this;\n  if (index === null) {\n    markers.push(edge);\n  } else {\n    markers.splice(index, 0, edge);\n  }\n  const enoughPoints = markers.length >= 3;\n  if (this.phase === 'draw') {\n    if (!enoughPoints) {\n      markers.forEach(({ marker }) => {\n        const icon = marker.getIcon();\n        icon.options.className = cls('area-select-marker', 'invalid');\n        marker.setIcon(icon);\n      });\n    } else if (markers.length === 3) {\n      // Restore colors\n      markers.forEach(({ marker }, index) => {\n        const icon = marker.getIcon();\n        icon.options.className = cls('area-select-marker', index === 0 ? 'start-marker' : null);\n        marker.setIcon(icon);\n      });\n    }\n  }\n  map.fire('as:update-polygon');\n  if (this.phase === 'adjust') {\n    map.fire('as:update-ghost-points');\n    this.onPolygonReady();\n  }\n\n  if (this.phase === 'draw') {\n    // close line\n    if (this.closeLine) {\n      map.removeLayer(this.closeLine);\n    }\n    if (enoughPoints) {\n      this.closeLine = new Polyline(\n        [\n          map.containerPointToLatLng(markers[0].point),\n          map.containerPointToLatLng(markers[markers.length - 1].point),\n        ],\n        {\n          weight: 3,\n          color: '#c0c0c0',\n        }\n      );\n      map.addLayer(this.closeLine);\n    }\n  }\n}\n\nexport function onRemoveMarker({ index = 0 }) {\n  const map = this.getMap();\n  const { markers } = this;\n  const enoughPoints = markers.length > 3;\n  if (!enoughPoints) {\n    return;\n  }\n  const removed = this.markers.splice(index || 0, 1);\n  removed[0].marker.removeFrom(map);\n  map.fire('as:update-polygon');\n  if (this.phase === 'adjust') {\n    map.fire('as:update-ghost-points');\n  }\n  for (let i = index; i < this.markers.length; i++) {\n    this.markers[i].marker.off('drag');\n    this.markers[i].marker.on('drag', onMarkerDrag.bind(this)(i));\n    this.markers[i].marker.off('dblclick');\n    this.markers[i].marker.on('dblclick', (event) => {\n      map.fire('as:marker-remove', {\n        ...this.markers[i],\n        index: i,\n      });\n    });\n  }\n}\n\n/**\n * Refresh the polygon on the map\n */\nexport function onUpdatePolygon() {\n  const map = this.getMap();\n  const { markers } = this;\n  const enoughPoints = markers.length >= 3;\n  const polygon = new Polygon(\n    markers.map(({ marker }) => {\n      return marker.getLatLng();\n      // return map.containerPointToLatLng(point);\n    }),\n    {\n      color: enoughPoints ? 'rgb(45, 123, 200)' : 'rgba(220, 53, 69, 0.7)',\n      weight: 2,\n      ...(!enoughPoints && { dashArray: '5, 10' }),\n    }\n  );\n  if (this.polygon) {\n    map.removeLayer(this.polygon);\n  }\n  this.polygon = polygon;\n  map.addLayer(this.polygon);\n}\n\nexport function onUpdateGhostPoints() {\n  const map = this.getMap();\n  global.requestAnimationFrame(() => {\n    this.clearGhostMarkers();\n    const { markers, ghostMarkers } = this;\n    markers.forEach((currentMarker, index) => {\n      const nextMarker = markers[index + 1] ? markers[index + 1] : markers[0];\n      const currentLatLng = currentMarker.marker.getLatLng();\n      const nextLatLng = nextMarker.marker.getLatLng();\n      const point = map.latLngToContainerPoint([\n        (currentLatLng.lat + nextLatLng.lat) / 2,\n        (currentLatLng.lng + nextLatLng.lng) / 2,\n      ]);\n\n      const icon = new DivIcon({\n        className: cls('area-select-ghost-marker'),\n        iconSize: [16, 16],\n      });\n      const marker = new Marker(map.containerPointToLatLng(point), {\n        icon,\n        draggable: true,\n      });\n      const newGhostMarker = {\n        point,\n        marker,\n      };\n      marker.on('drag', onGhostMarkerDrag.bind(this)(ghostMarkers.length));\n      marker.on('dragstart', onGhostMarkerDragStart.bind(this)());\n      marker.on('dragend', onGhostMarkerDragEnd.bind(this)(ghostMarkers.length));\n      ghostMarkers.push(newGhostMarker);\n      marker.addTo(map);\n    });\n  });\n}\n\nexport function onPolygonCreationEnd() {\n  const map = this.getMap();\n  map.removeLayer(this.closeLine);\n  this.closeLine = null;\n  // Remove style for the final marker icon\n  this.markers[0].marker.getElement().classList.remove('start-marker');\n  this.setPhase('adjust');\n  map.fire('as:update-ghost-points');\n  this.onPolygonReady();\n}\n\nexport function onActivate(event) {\n  event.preventDefault();\n  event.target.blur();\n  // if current state is active, we need to deactivate\n  const activeState = this.options.active || this.phase === 'adjust';\n  activeState\n    ? this.activateButton.classList.remove('active')\n    : this.activateButton.classList.add('active');\n  this.setPhase(activeState ? 'inactive' : 'draw', true);\n}\n\nexport function onMarkerDrag(index) {\n  const map = this.getMap();\n  return (event) => {\n    const { latlng } = event;\n    global.requestAnimationFrame(() => {\n      const newPoint = map.latLngToContainerPoint(latlng);\n      const { point } = this.markers[index];\n      point.x = newPoint.x;\n      point.y = newPoint.y;\n      map.fire('as:update-polygon');\n      map.fire('as:update-ghost-points');\n    });\n  };\n}\n\nexport function onGhostMarkerDrag(index) {\n  const map = this.getMap();\n  return (event) => {\n    const { latlng } = event;\n    global.requestAnimationFrame(() => {\n      // Given a ghost point, markers to be used as edges are the one at +0 and +1\n      const firstPoint = this.markers[index];\n      const lastPoint = this.markers[index + 1] ? this.markers[index + 1] : this.markers[0];\n      if (this.ghostPolygon) {\n        map.removeLayer(this.ghostPolygon);\n      }\n      this.ghostPolygon = new Polygon(\n        [\n          map.containerPointToLatLng(firstPoint.point),\n          latlng,\n          map.containerPointToLatLng(lastPoint.point),\n        ],\n        {\n          color: 'rgb(45, 123, 200)',\n          weight: 2,\n          opacity: 0.5,\n          fillOpacity: 0.1,\n          dashArray: '5, 10',\n        }\n      );\n      map.addLayer(this.ghostPolygon);\n      map.fire('as:update-polygon');\n    });\n  };\n}\n\nexport function onGhostMarkerDragStart() {\n  return (event) => {\n    event.target.getElement().classList.add('active');\n  };\n}\n\nexport function onGhostMarkerDragEnd(index) {\n  const map = this.getMap();\n  return (event) => {\n    const { target } = event;\n    target.getElement().classList.remove('active');\n    target.removeFrom(map);\n    if (this.ghostPolygon) {\n      map.removeLayer(this.ghostPolygon);\n    }\n    const newPoint = map.latLngToContainerPoint(target.getLatLng());\n    const fakeEvent = {\n      clientX: newPoint.x,\n      clientY: newPoint.y,\n      index: index + 1,\n    };\n    map.fire('as:point-add', fakeEvent);\n  };\n}\n","import { DomUtil, Control, Util, Point } from 'leaflet';\nimport { createPane, PANE_NAME } from './drawing-pane';\nimport { cls, setPosition, CLICK_EVT } from './utils';\nimport {\n  onActivate,\n  onAddMarker,\n  onAddPoint,\n  onPolygonCreationEnd,\n  onRemoveMarker,\n  onUpdateGhostPoints,\n  onUpdatePolygon,\n} from './events';\nimport iconImage from 'images/area-icon.svg';\n\nexport const DrawAreaSelection = Control.extend({\n  options: {\n    // activate automatically area selection on plugin load\n    active: false,\n    // callback called when draw phase is complete and at every polygon adjustement\n    onPolygonReady: (polygon) => {},\n    // partially fade the map when draw phase is activated\n    fadeOnActivation: true,\n  },\n\n  initialize: function (options = {}) {\n    Util.setOptions(this, options);\n    // lifecycle phases: one of inactive, draw, adjust\n    this.phase = options.active ? 'draw' : 'inactive';\n    this.map_moving = false;\n    // edge markers used for drawing, next dragging the polygon\n    this.markers = [];\n    // fake markers used for adding rings to the polygon\n    this.ghostMarkers = [];\n    // The actual polygon draw\n    this.polygon = null;\n    // on drawing phase: a line from the last drawn point to the first ones\n    this.closeLine = null;\n\n    this._mapMoveStart = this.mapMoveStart.bind(this);\n    this._mapMoveEnd = this.mapMoveEnd.bind(this);\n  },\n\n  onAdd: function (map) {\n    this._container = DomUtil.create('div', cls('leaflet-area-selector-control'));\n    this.activateButton = DomUtil.create('button', '', this._container);\n    this.activateButton.addEventListener(CLICK_EVT, onActivate.bind(this));\n    this.activateButton.addEventListener('dblclick', (event) => {\n      event.stopPropagation();\n    });\n    this.options.active\n      ? this.activateButton.classList.add('active')\n      : this.activateButton.classList.remove('active');\n    const icon = DomUtil.create('img', '', this.activateButton);\n    icon.setAttribute('src', iconImage);\n    this._map = map;\n    createPane(map, this.options);\n    map.on('movestart', this._mapMoveStart);\n    map.on('moveend', this._mapMoveEnd);\n    map.on('as:point-add', onAddPoint.bind(this));\n    map.on('as:marker-add', onAddMarker.bind(this));\n    map.on('as:marker-remove', onRemoveMarker.bind(this));\n    map.on('as:creation-end', onPolygonCreationEnd.bind(this));\n    map.on('as:update-polygon', onUpdatePolygon.bind(this));\n    map.on('as:update-ghost-points', onUpdateGhostPoints.bind(this));\n    return this._container;\n  },\n\n  onRemove: function (map) {\n    map.on('movestart', this._mapMoveStart);\n    map.on('moveend', this._mapMoveEnd);\n    map.off('as:point-add');\n    map.off('as:marker-add');\n    map.off('as:marker-remove');\n    map.off('as:creation-end');\n    map.off('as:update-polygon');\n    map.off('as:update-ghost-points');\n  },\n\n  getMap: function () {\n    return this._map;\n  },\n\n  onPolygonReady: function () {\n    this.options.onPolygonReady(this.polygon);\n  },\n\n  setPhase(phase, forceClear = false) {\n    this.phase = phase;\n    this.options.active = phase === 'draw';\n    // If we didn't finished to fill a polygon, let's clear all\n    if (forceClear || this.phase === 'draw') {\n      this.clearGhostMarkers();\n      this.clearMarkers();\n      this.clearPolygon();\n    }\n    const pane = this._map.getPane(PANE_NAME);\n    const container = pane.parentNode;\n    this.options.active\n      ? container.classList.remove('inactive')\n      : container.classList.add('inactive');\n  },\n\n  mapMoveStart: function () {\n    this.map_moving = true;\n  },\n\n  mapMoveEnd: function (event) {\n    global.requestAnimationFrame(() => {\n      this.map_moving = false;\n    });\n    const map = this._map;\n    // Re-position end of selection HTML element\n    const pane = map.getPane(PANE_NAME);\n    const touchMarker = pane.querySelector('.end-selection-area');\n    if (touchMarker) {\n      const firstMarker = this.markers[0].marker;\n      const bbox = touchMarker.getBoundingClientRect();\n      const point = map.latLngToContainerPoint(firstMarker.getLatLng());\n      setPosition(touchMarker, point, new Point(-bbox.width / 2, -bbox.height / 2));\n    }\n    this.translatePolygon();\n  },\n\n  translatePolygon: function () {\n    if (this.markers.length === 0) {\n      return;\n    }\n    const map = this._map;\n    this.markers.forEach((data) => {\n      data.point = map.latLngToContainerPoint(data.marker.getLatLng());\n    });\n    this.ghostMarkers.forEach((data) => {\n      data.point = map.latLngToContainerPoint(data.marker.getLatLng());\n    });\n  },\n\n  hoverClosePoint: function (event) {\n    if (this.markers.length > 2 && this.closeLine) {\n      this.closeLine.removeFrom(this._map);\n    }\n  },\n\n  outClosePoint: function (event) {\n    if (this.closeLine) {\n      this.closeLine.addTo(this._map);\n    }\n  },\n\n  clearMarkers: function () {\n    this.markers.forEach(({ marker }) => {\n      marker.removeFrom(this._map);\n    });\n    this.markers = [];\n  },\n\n  clearGhostMarkers: function () {\n    this.ghostMarkers.forEach(({ marker }) => {\n      marker.removeFrom(this._map);\n    });\n    this.ghostMarkers = [];\n  },\n\n  clearPolygon: function () {\n    this.polygon && this.polygon.removeFrom(this._map);\n    this.polygon = null;\n    this.closeLine && this.closeLine.removeFrom(this._map);\n    this.closeLine = null;\n  },\n});\n\nexport const drawAreaSelection = function (options = {}) {\n  return new DrawAreaSelection(options);\n};\n","module.exports = __webpack_public_path__ + \"static/media/area-icon~bdUaMhse.01b4354a.svg\";","module.exports = __webpack_public_path__ + \"static/media/B-Open.a8695c4b.svg\";","import L from 'leaflet';\nimport 'leaflet/dist/leaflet.css';\nimport '@bopen/leaflet-area-selection/dist/index.css';\nimport { DrawAreaSelection } from '@bopen/leaflet-area-selection';\n\nimport './index.css';\n\nimport icon from './B-Open.svg';\n\n// See https://github.com/Leaflet/Leaflet/issues/4968#issuecomment-483402699\ndelete L.Icon.Default.prototype._getIconUrl;\nL.Icon.Default.mergeOptions({\n  iconRetinaUrl: require('leaflet/dist/images/marker-icon-2x.png'),\n  iconUrl: require('leaflet/dist/images/marker-icon.png'),\n  shadowUrl: require('leaflet/dist/images/marker-shadow.png'),\n});\n\nconst center = [41.901493, 12.5009157];\n\nconst map = L.map('root').setView(center, 13);\n\nL.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n  attribution:\n    '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors',\n}).addTo(map);\n\nconst popup = document.createElement('div');\npopup.innerHTML = `<div style=\"text-align: center; font-size: 120%\">B-Open</div>\n<img alt=\"B-Open logo\" width=\"75\" src=\"${icon}\" />\n`;\n\nL.marker(center)\n  .addTo(map, {\n    // Required for a bug in Leaflet 1.7.1. See https://github.com/Leaflet/Leaflet/issues/7255\n    tap: false,\n  })\n  .bindPopup(popup);\n\nconst areaSelection = new DrawAreaSelection({\n  active: true,\n  // fadeOnActivation: false,\n  onPolygonReady: (polygon) => {\n    const preview = document.getElementById('polygon');\n    preview.innerText = JSON.stringify(polygon.toGeoJSON(2), undefined, 2);\n    preview.scrollTop = preview.scrollHeight;\n  },\n  position: 'bottomleft',\n});\n\nmap.addControl(areaSelection);\n"],"sourceRoot":""}